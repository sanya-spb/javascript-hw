// 2. Не выполняя кода, ответить, что выведет браузер и почему:

if (!("a" in window)) {
    var a = 1;
}
alert(a);
/*
undefined

"var a" - производит всплытие (hoist) переменной "а" в область "window" (т.е. глобально).
Однако присвоение переменной производится только внутри if'а, условия которого теперь уже не выполнятся
*/

var b = function a(x) {
    x && a(--x);
};
alert(a);
/*
a is not defined

тут похоже, что-то не хватает, но суть в следующем: 
b - функциональное выражение и оно выполняется только в том месте где существует в програмном коде, всплытия не происходит.
если определить переменную "a" и присвоить ей что-нить, то это что-нить мы и увидим, несмотря на то что "a" было объявлено как функция
перепишем пример:
var b = function (x) {
    x && b(--x);
};
alert(a);
так понятнее, что "a" - нет в глобальной области видимости, так же как и в исходном коде функциональное выражение не hoist'ит переменную (назв. ф-ции) "a".
*/

function a(x) {
    return x * 2;
}
var a;
alert(a);
/*
выводит описание ф-ции a(x)

ответ нашел в методичке: в процессе чтения кода создается функция и переменная, у которой имя будет совпадать с именем функции.
получается, строка "var a;" не производит присваивание, поэтому выводится описание функции, которое было присвоено переменной а при создании функции.
+ работает концепция JS, где объявления функций переопределяют определения переменных.
*/

function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);
/*
10

через параметры передаем 1,2,3;
далее внутри функции у нас создается пространство памяти, в котором содержатся копии параметров. 
в том числе создается объект arguments который является дубликатом каждого именованного аргумента, + они синронизированны между собой (ссылаются на одни и теже значения)
меняем/переприсваиваем третий параметр (по индексу 2)
и выводим его (точнее то на что переприсвоили).
*/

function a() {
    alert(this);
}
a.call(null);
/*
window

Метод call() выполняет функцию так, как если бы это был метод другого объекта.
При этом первый параметр метода call() используется в качестве значения this
Однако, Если первый параметр имеет значение null или undefined, вызываемой функции передается глобальный объект в качестве значения this.
Глобальным объектом в браузере у нас является window.
*/
